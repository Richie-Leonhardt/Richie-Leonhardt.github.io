<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sort on Richie&#39;s Blog</title>
    <link>https://richie-leonhardt.github.io/tags/sort/</link>
    <description>Recent content in sort on Richie&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 14 Jul 2020 13:46:02 +0800</lastBuildDate>
    
	<atom:link href="https://richie-leonhardt.github.io/tags/sort/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>排序总结_C实现</title>
      <link>https://richie-leonhardt.github.io/2020/07/14/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93_c%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 14 Jul 2020 13:46:02 +0800</pubDate>
      
      <guid>https://richie-leonhardt.github.io/2020/07/14/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93_c%E5%AE%9E%E7%8E%B0/</guid>
      <description>快速排序 //快速排序 #include &amp;lt;stdio.h&amp;gt;#define N 8  //左右搜索，将比枢轴大的元素移到后面，比枢轴小的移到前面，可以通过交替找的方法将那个枢轴空出来的位置充分利用起来，不交换而采取移动的方式 int Partition(int sqList[], int low, int high){ int pivokey = sqList[low]; while( low &amp;lt; high ){ while ( low &amp;lt; high &amp;amp;&amp;amp; sqList[high] &amp;gt;= pivokey ) high--;	//因为一直往前移动搜索比枢轴小的数字，如果搜到头都没找到，则会出现越界，所以一定要加上low &amp;lt; high的条件不能少 	sqList[low] = sqList[high]; while ( low &amp;lt; high &amp;amp;&amp;amp; sqList[low] &amp;lt;= pivokey ) low++;	sqList[high] = sqList[low]; } /*最后枢轴返回位置的时候要考虑到，没执行while和执行了while的情况，执行了while就要找中间那个位置，发现high和low都行，但是若没执行while就必须low了，所以最后必须是low*/ sqList[low] = pivokey; return low; } //每次分割开来左右递归 void Qsort(int sqList[], int low, int high){ int pivoloc; if(low &amp;lt; high){ pivoloc = Partition(sqList,low,high); Qsort(sqList, low, pivoloc - 1); Qsort(sqList, pivoloc + 1,high); } } void printList(int sqList[]){ int i; for ( i = 0; i &amp;lt; N; ++i ) printf(&amp;#34;%d &amp;#34;,sqList[i] ); } int main(int argc, char const *argv[]) { int i; int sqList[N]; printf(&amp;#34;请输入8个数字，以空格隔开：&amp;#34;); for (i = 0; i &amp;lt; N; i++) scanf(&amp;#34;%d&amp;#34;,&amp;amp;sqList[i]); Qsort(sqList,0,N-1); printList(sqList); return 0; } /* example input: 3 5 2 9 6 8 3 1 */ 基数排序 /* 基数排序 * 基数排序是针对非负整数或是非正整数的序列进行的排序 * 基数排序是先根据个位数进行排序，再根据十位数进行排序，再百位数…… * 基数排序的基本过程： * 1.</description>
    </item>
    
  </channel>
</rss>